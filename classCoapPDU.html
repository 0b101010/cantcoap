<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>Can&#39;t CoAP: CoapPDU Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Can&#39;t CoAP
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.1.2 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="classCoapPDU-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">CoapPDU Class Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCoapPDU_1_1CoapOption.html">CoapOption</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sequence of these is returned by <a class="el" href="classCoapPDU.html#a206a01d5de8f1bb4ca6ae3b7825a7b02">CoapPDU::getOptions()</a>  <a href="structCoapPDU_1_1CoapOption.html#details">More...</a><br/></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a344de2a536c11a30bc370202605a47c3"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCoapPDU.html#a344de2a536c11a30bc370202605a47c3">Type</a> { <b>COAP_CONFIRMABLE</b> = 0x00, 
<b>COAP_NON_CONFIRMABLE</b> = 0x10, 
<b>COAP_ACKNOWLEDGEMENT</b> = 0x20, 
<b>COAP_RESET</b> = 0x30
 }</td></tr>
<tr class="memdesc:a344de2a536c11a30bc370202605a47c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">CoAP message types. Note, values only work as enum. <br/></td></tr>
<tr class="memitem:af93689fd3000125b1144b91c323f804d"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><b>Code</b> { <br/>
&#160;&#160;<b>COAP_EMPTY</b> = 0x00, 
<b>COAP_GET</b>, 
<b>COAP_POST</b>, 
<b>COAP_PUT</b>, 
<br/>
&#160;&#160;<b>COAP_DELETE</b>, 
<b>COAP_CREATED</b> = 0x41, 
<b>COAP_DELETED</b>, 
<b>COAP_VALID</b>, 
<br/>
&#160;&#160;<b>COAP_CHANGED</b>, 
<b>COAP_CONTENT</b>, 
<b>COAP_BAD_REQUEST</b> = 0x80, 
<b>COAP_UNAUTHORIZED</b>, 
<br/>
&#160;&#160;<b>COAP_BAD_OPTION</b>, 
<b>COAP_FORBIDDEN</b>, 
<b>COAP_NOT_FOUND</b>, 
<b>COAP_METHOD_NOT_ALLOWED</b>, 
<br/>
&#160;&#160;<b>COAP_NOT_ACCEPTABLE</b>, 
<b>COAP_PRECONDITION_FAILED</b> = 0x8C, 
<b>COAP_REQUEST_ENTITY_TOO_LARGE</b> = 0x8D, 
<b>COAP_UNSUPPORTED_CONTENT_FORMAT</b> = 0x8F, 
<br/>
&#160;&#160;<b>COAP_INTERNAL_SERVER_ERROR</b> = 0xA0, 
<b>COAP_NOT_IMPLEMENTED</b>, 
<b>COAP_BAD_GATEWAY</b>, 
<b>COAP_SERVICE_UNAVAILABLE</b>, 
<br/>
&#160;&#160;<b>COAP_GATEWAY_TIMEOUT</b>, 
<b>COAP_PROXYING_NOT_SUPPORTED</b>
<br/>
 }</td></tr>
<tr class="memitem:a14532c22e1b6afd2f97300afefc45aee"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCoapPDU.html#a14532c22e1b6afd2f97300afefc45aee">Option</a> { <br/>
&#160;&#160;<b>COAP_OPTION_IF_MATCH</b> = 1, 
<b>COAP_OPTION_URI_HOST</b> = 3, 
<b>COAP_OPTION_ETAG</b>, 
<b>COAP_OPTION_IF_NONE_MATCH</b>, 
<br/>
&#160;&#160;<b>COAP_OPTION_URI_PORT</b> = 7, 
<b>COAP_OPTION_LOCATION_PATH</b>, 
<b>COAP_OPTION_URI_PATH</b> = 11, 
<b>COAP_OPTION_CONTENT_FORMAT</b>, 
<br/>
&#160;&#160;<b>COAP_OPTION_MAX_AGE</b> = 14, 
<b>COAP_OPTION_URI_QUERY</b>, 
<b>COAP_OPTION_ACCEPT</b> = 17, 
<b>COAP_OPTION_LOCATION_QUERY</b> = 20, 
<br/>
&#160;&#160;<b>COAP_OPTION_BLOCK2</b> = 23, 
<b>COAP_OPTION_BLOCK1</b> = 27, 
<b>COAP_OPTION_SIZE2</b>, 
<b>COAP_OPTION_PROXY_URI</b> = 35, 
<br/>
&#160;&#160;<b>COAP_OPTION_PROXY_SCHEME</b> = 39, 
<b>COAP_OPTION_SIZE1</b> = 60
<br/>
 }</td></tr>
<tr class="memdesc:a14532c22e1b6afd2f97300afefc45aee"><td class="mdescLeft">&#160;</td><td class="mdescRight">CoAP option numbers. <br/></td></tr>
<tr class="memitem:a47254e03045e0ad9617b231a0589b98d"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCoapPDU.html#a47254e03045e0ad9617b231a0589b98d">ContentFormat</a> { <br/>
&#160;&#160;<b>COAP_CONTENT_FORMAT_TEXT_PLAIN</b> =  0, 
<b>COAP_CONTENT_FORMAT_APP_LINK</b> =  40, 
<b>COAP_CONTENT_FORMAT_APP_XML</b>, 
<b>COAP_CONTENT_FORMAT_APP_OCTET</b>, 
<br/>
&#160;&#160;<b>COAP_CONTENT_FORMAT_APP_EXI</b> =  47, 
<b>COAP_CONTENT_FORMAT_APP_JSON</b> =  50
<br/>
 }</td></tr>
<tr class="memdesc:a47254e03045e0ad9617b231a0589b98d"><td class="mdescLeft">&#160;</td><td class="mdescRight">CoAP content-formats. <br/></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a3cb874140adc2776f47bbfa20e881e67"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCoapPDU.html#a3cb874140adc2776f47bbfa20e881e67">CoapPDU</a> ()</td></tr>
<tr class="memdesc:a3cb874140adc2776f47bbfa20e881e67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Memory-managed constructor. Buffer for PDU is dynamically sized and allocated by the object.  <a href="#a3cb874140adc2776f47bbfa20e881e67"></a><br/></td></tr>
<tr class="memitem:a9aadbbfe0baa66b6d825636d4211d6bb"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCoapPDU.html#a9aadbbfe0baa66b6d825636d4211d6bb">CoapPDU</a> (uint8_t *pdu, int pduLength)</td></tr>
<tr class="memdesc:a9aadbbfe0baa66b6d825636d4211d6bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a PDU using an external buffer. No copy of the buffer is made.  <a href="#a9aadbbfe0baa66b6d825636d4211d6bb"></a><br/></td></tr>
<tr class="memitem:a55c638acbe1b4fd7b4a288a126078c86"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCoapPDU.html#a55c638acbe1b4fd7b4a288a126078c86">CoapPDU</a> (uint8_t *buffer, int bufferLength, int pduLength)</td></tr>
<tr class="memdesc:a55c638acbe1b4fd7b4a288a126078c86"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct object from external buffer that may be larger than actual PDU.  <a href="#a55c638acbe1b4fd7b4a288a126078c86"></a><br/></td></tr>
<tr class="memitem:a00473911b9b2c209a0c25c75ef4a1a77"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCoapPDU.html#a00473911b9b2c209a0c25c75ef4a1a77">~CoapPDU</a> ()</td></tr>
<tr class="memdesc:a00473911b9b2c209a0c25c75ef4a1a77"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor. Does not free buffer if constructor passed an external buffer.  <a href="#a00473911b9b2c209a0c25c75ef4a1a77"></a><br/></td></tr>
<tr class="memitem:add695cf1e57cae13cfbfb9b6964a4456"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCoapPDU.html#add695cf1e57cae13cfbfb9b6964a4456">reset</a> ()</td></tr>
<tr class="memdesc:add695cf1e57cae13cfbfb9b6964a4456"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset <a class="el" href="classCoapPDU.html">CoapPDU</a> container so it can be reused to build a new PDU.  <a href="#add695cf1e57cae13cfbfb9b6964a4456"></a><br/></td></tr>
<tr class="memitem:a757ad675b619f32b81c8c435792f4f9c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCoapPDU.html#a757ad675b619f32b81c8c435792f4f9c">validate</a> ()</td></tr>
<tr class="memdesc:a757ad675b619f32b81c8c435792f4f9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Validates a PDU constructed using an external buffer.  <a href="#a757ad675b619f32b81c8c435792f4f9c"></a><br/></td></tr>
<tr class="memitem:ad20036b2ab718aa1fe0303cadfa091d6"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCoapPDU.html#ad20036b2ab718aa1fe0303cadfa091d6">setVersion</a> (uint8_t version)</td></tr>
<tr class="memdesc:ad20036b2ab718aa1fe0303cadfa091d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the CoAP version.  <a href="#ad20036b2ab718aa1fe0303cadfa091d6"></a><br/></td></tr>
<tr class="memitem:a6e4d0602e21b8f55d12dd2a57e0db051"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCoapPDU.html#a6e4d0602e21b8f55d12dd2a57e0db051">getVersion</a> ()</td></tr>
<tr class="memitem:a5aed3e2860acdd3beeac6a812fcf4700"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCoapPDU.html#a5aed3e2860acdd3beeac6a812fcf4700">setType</a> (<a class="el" href="classCoapPDU.html#a344de2a536c11a30bc370202605a47c3">CoapPDU::Type</a> type)</td></tr>
<tr class="memitem:a62840e22b3a36f5bb5459e4ecb8e882a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a62840e22b3a36f5bb5459e4ecb8e882a"></a>
<a class="el" href="classCoapPDU.html#a344de2a536c11a30bc370202605a47c3">CoapPDU::Type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCoapPDU.html#a62840e22b3a36f5bb5459e4ecb8e882a">getType</a> ()</td></tr>
<tr class="memdesc:a62840e22b3a36f5bb5459e4ecb8e882a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the type of the PDU. <br/></td></tr>
<tr class="memitem:a371af095ec9b05194212abe4d3df5e6d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCoapPDU.html#a371af095ec9b05194212abe4d3df5e6d">setTokenLength</a> (uint8_t tokenLength)</td></tr>
<tr class="memdesc:a371af095ec9b05194212abe4d3df5e6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the token length.  <a href="#a371af095ec9b05194212abe4d3df5e6d"></a><br/></td></tr>
<tr class="memitem:a142b492a6551b52028b908f5dc38cb88"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a142b492a6551b52028b908f5dc38cb88"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCoapPDU.html#a142b492a6551b52028b908f5dc38cb88">getTokenLength</a> ()</td></tr>
<tr class="memdesc:a142b492a6551b52028b908f5dc38cb88"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the token length. <br/></td></tr>
<tr class="memitem:a528f14f71fc19a6e4cff3a8775e167e3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a528f14f71fc19a6e4cff3a8775e167e3"></a>
uint8_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCoapPDU.html#a528f14f71fc19a6e4cff3a8775e167e3">getTokenPointer</a> ()</td></tr>
<tr class="memdesc:a528f14f71fc19a6e4cff3a8775e167e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a pointer to the PDU token. <br/></td></tr>
<tr class="memitem:adafa3fa099f4ba5248a05bb4a120bbed"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCoapPDU.html#adafa3fa099f4ba5248a05bb4a120bbed">setToken</a> (uint8_t *token, uint8_t tokenLength)</td></tr>
<tr class="memdesc:adafa3fa099f4ba5248a05bb4a120bbed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the PDU token to the supplied byte sequence.  <a href="#adafa3fa099f4ba5248a05bb4a120bbed"></a><br/></td></tr>
<tr class="memitem:a45b63b94ede0981380517a08fbd52058"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a45b63b94ede0981380517a08fbd52058"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCoapPDU.html#a45b63b94ede0981380517a08fbd52058">setCode</a> (CoapPDU::Code code)</td></tr>
<tr class="memdesc:a45b63b94ede0981380517a08fbd52058"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the CoAP response code. <br/></td></tr>
<tr class="memitem:a3ec6cccf7445cb1d934f28ec5e35aadb"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3ec6cccf7445cb1d934f28ec5e35aadb"></a>
CoapPDU::Code&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCoapPDU.html#a3ec6cccf7445cb1d934f28ec5e35aadb">getCode</a> ()</td></tr>
<tr class="memdesc:a3ec6cccf7445cb1d934f28ec5e35aadb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the CoAP response code. <br/></td></tr>
<tr class="memitem:afd64c65662e72058abe6008a1abe08ec"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCoapPDU.html#afd64c65662e72058abe6008a1abe08ec">setMessageID</a> (uint16_t messageID)</td></tr>
<tr class="memdesc:afd64c65662e72058abe6008a1abe08ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set messageID to the supplied value.  <a href="#afd64c65662e72058abe6008a1abe08ec"></a><br/></td></tr>
<tr class="memitem:a4521a9c91121aec37a5a879639d9a7c6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4521a9c91121aec37a5a879639d9a7c6"></a>
uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCoapPDU.html#a4521a9c91121aec37a5a879639d9a7c6">getMessageID</a> ()</td></tr>
<tr class="memdesc:a4521a9c91121aec37a5a879639d9a7c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the 16 bit message ID of the PDU. <br/></td></tr>
<tr class="memitem:aab90c3016ce4eeb3b8580e43233e131f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCoapPDU.html#aab90c3016ce4eeb3b8580e43233e131f">addOption</a> (uint16_t optionNumber, uint16_t optionLength, uint8_t *optionValue)</td></tr>
<tr class="memdesc:aab90c3016ce4eeb3b8580e43233e131f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add an option to the PDU.  <a href="#aab90c3016ce4eeb3b8580e43233e131f"></a><br/></td></tr>
<tr class="memitem:a206a01d5de8f1bb4ca6ae3b7825a7b02"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structCoapPDU_1_1CoapOption.html">CoapOption</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCoapPDU.html#a206a01d5de8f1bb4ca6ae3b7825a7b02">getOptions</a> ()</td></tr>
<tr class="memitem:af7b976007766c3c4b5fafee67ab20b5a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af7b976007766c3c4b5fafee67ab20b5a"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCoapPDU.html#af7b976007766c3c4b5fafee67ab20b5a">getNumOptions</a> ()</td></tr>
<tr class="memdesc:af7b976007766c3c4b5fafee67ab20b5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of options that the PDU has. <br/></td></tr>
<tr class="memitem:a5a53a8147901753189773d9eabe1d142"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCoapPDU.html#a5a53a8147901753189773d9eabe1d142">setURI</a> (char *uri, int urilen)</td></tr>
<tr class="memdesc:a5a53a8147901753189773d9eabe1d142"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shorthand function for setting a resource URI.  <a href="#a5a53a8147901753189773d9eabe1d142"></a><br/></td></tr>
<tr class="memitem:ab84a11627b55810181d82b673d674468"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCoapPDU.html#ab84a11627b55810181d82b673d674468">getURI</a> (char *dst, int dstlen, int *outLen)</td></tr>
<tr class="memdesc:ab84a11627b55810181d82b673d674468"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concatenates any URI_PATH elements into a single string.  <a href="#ab84a11627b55810181d82b673d674468"></a><br/></td></tr>
<tr class="memitem:afc7d3485afa5f4c84f55a41562305d0f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCoapPDU.html#afc7d3485afa5f4c84f55a41562305d0f">setContentFormat</a> (<a class="el" href="classCoapPDU.html#a47254e03045e0ad9617b231a0589b98d">CoapPDU::ContentFormat</a> format)</td></tr>
<tr class="memdesc:afc7d3485afa5f4c84f55a41562305d0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shorthand for setting the content-format option.  <a href="#afc7d3485afa5f4c84f55a41562305d0f"></a><br/></td></tr>
<tr class="memitem:a73fa1f5ddfa6be212d2e5e1182c4afc3"><td class="memItemLeft" align="right" valign="top">uint8_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCoapPDU.html#a73fa1f5ddfa6be212d2e5e1182c4afc3">mallocPayload</a> (int bytes)</td></tr>
<tr class="memdesc:a73fa1f5ddfa6be212d2e5e1182c4afc3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate space for a payload.  <a href="#a73fa1f5ddfa6be212d2e5e1182c4afc3"></a><br/></td></tr>
<tr class="memitem:a68d5b39701189a853eb5403a1a1a77e0"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCoapPDU.html#a68d5b39701189a853eb5403a1a1a77e0">setPayload</a> (uint8_t *value, int len)</td></tr>
<tr class="memdesc:a68d5b39701189a853eb5403a1a1a77e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the payload to the byte sequence specified. Allocates memory in dynamic PDU if necessary.  <a href="#a68d5b39701189a853eb5403a1a1a77e0"></a><br/></td></tr>
<tr class="memitem:a882086a5282247aba163eb6960661cf5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a882086a5282247aba163eb6960661cf5"></a>
uint8_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCoapPDU.html#a882086a5282247aba163eb6960661cf5">getPayloadPointer</a> ()</td></tr>
<tr class="memdesc:a882086a5282247aba163eb6960661cf5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a pointer to the payload buffer. <br/></td></tr>
<tr class="memitem:a9e5a67c947d9b4dbc18655dbf67c3815"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9e5a67c947d9b4dbc18655dbf67c3815"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCoapPDU.html#a9e5a67c947d9b4dbc18655dbf67c3815">getPayloadLength</a> ()</td></tr>
<tr class="memdesc:a9e5a67c947d9b4dbc18655dbf67c3815"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the length of the payload buffer. <br/></td></tr>
<tr class="memitem:af7c7c5d863c95949ebff3078ae87d7f8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af7c7c5d863c95949ebff3078ae87d7f8"></a>
uint8_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCoapPDU.html#af7c7c5d863c95949ebff3078ae87d7f8">getPayloadCopy</a> ()</td></tr>
<tr class="memdesc:af7c7c5d863c95949ebff3078ae87d7f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a pointer to a buffer which is a copy of the payload buffer (dynamically allocated). <br/></td></tr>
<tr class="memitem:a4bba97161bdc42ae88ff8787ca1779f0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4bba97161bdc42ae88ff8787ca1779f0"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCoapPDU.html#a4bba97161bdc42ae88ff8787ca1779f0">getPDULength</a> ()</td></tr>
<tr class="memdesc:a4bba97161bdc42ae88ff8787ca1779f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the length of the PDU. <br/></td></tr>
<tr class="memitem:af02b5f6354c577957ab8a7fd307c11b1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af02b5f6354c577957ab8a7fd307c11b1"></a>
uint8_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCoapPDU.html#af02b5f6354c577957ab8a7fd307c11b1">getPDUPointer</a> ()</td></tr>
<tr class="memdesc:af02b5f6354c577957ab8a7fd307c11b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a pointer to the internal buffer. <br/></td></tr>
<tr class="memitem:ad379ea8c694670b3dc95657fdc5ae1eb"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad379ea8c694670b3dc95657fdc5ae1eb"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCoapPDU.html#ad379ea8c694670b3dc95657fdc5ae1eb">print</a> ()</td></tr>
<tr class="memdesc:ad379ea8c694670b3dc95657fdc5ae1eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dumps the PDU as a byte sequence to stdout. <br/></td></tr>
<tr class="memitem:aeb71245fa6f59263271c3d107ab9712b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aeb71245fa6f59263271c3d107ab9712b"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCoapPDU.html#aeb71245fa6f59263271c3d107ab9712b">printBin</a> ()</td></tr>
<tr class="memdesc:aeb71245fa6f59263271c3d107ab9712b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dumps the entire PDU in binary. <br/></td></tr>
<tr class="memitem:a463102043beaea8cb7620f3d28d3d70d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a463102043beaea8cb7620f3d28d3d70d"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCoapPDU.html#a463102043beaea8cb7620f3d28d3d70d">printHex</a> ()</td></tr>
<tr class="memdesc:a463102043beaea8cb7620f3d28d3d70d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dumps the PDU header in hex. <br/></td></tr>
<tr class="memitem:ab00a78b493dc0df018f3a3e5ee058d15"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCoapPDU.html#ab00a78b493dc0df018f3a3e5ee058d15">printOptionHuman</a> (uint8_t *option)</td></tr>
<tr class="memdesc:ab00a78b493dc0df018f3a3e5ee058d15"><td class="mdescLeft">&#160;</td><td class="mdescRight">A routine for printing an option in human-readable format.  <a href="#ab00a78b493dc0df018f3a3e5ee058d15"></a><br/></td></tr>
<tr class="memitem:a0c0ba3c365647178f04e84c8e2412785"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0c0ba3c365647178f04e84c8e2412785"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCoapPDU.html#a0c0ba3c365647178f04e84c8e2412785">printHuman</a> ()</td></tr>
<tr class="memdesc:a0c0ba3c365647178f04e84c8e2412785"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints the PDU in human-readable format. <br/></td></tr>
<tr class="memitem:ad7583f4b6194311b9c3c582ae9e7281c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad7583f4b6194311b9c3c582ae9e7281c"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCoapPDU.html#ad7583f4b6194311b9c3c582ae9e7281c">printPDUAsCArray</a> ()</td></tr>
<tr class="memdesc:ad7583f4b6194311b9c3c582ae9e7281c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints the PDU as a c array (useful for debugging or hardcoding PDUs) <br/></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a5437897cce468471687a98163567e745"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5437897cce468471687a98163567e745"></a>
static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCoapPDU.html#a5437897cce468471687a98163567e745">printBinary</a> (uint8_t b)</td></tr>
<tr class="memdesc:a5437897cce468471687a98163567e745"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints a single byte in binary. <br/></td></tr>
</table>
<h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a3cb874140adc2776f47bbfa20e881e67"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CoapPDU::CoapPDU </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Memory-managed constructor. Buffer for PDU is dynamically sized and allocated by the object. </p>
<p>When using this constructor, the <a class="el" href="classCoapPDU.html">CoapPDU</a> class will allocate space for the PDU. Contrast this with the parameterized constructors, which allow the use of an external buffer.</p>
<p>Note, the PDU container and space can be reused by issuing a <a class="el" href="classCoapPDU.html#add695cf1e57cae13cfbfb9b6964a4456" title="Reset CoapPDU container so it can be reused to build a new PDU.">CoapPDU::reset()</a>. If the new PDU exceeds the space of the previously allocated memory, then further memory will be dynamically allocated.</p>
<p>Deleting the object will free the Object container and all dynamically allocated memory.</p>
<dl class="section note"><dt>Note</dt><dd>It would have been nice to use something like UDP_CORK or MSG_MORE, to allow separate buffers for token, options, and payload but these FLAGS aren't implemented for UDP in LwIP so stuck with one buffer for now.</dd></dl>
<p>CoAP version defaults to 1.</p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="classCoapPDU.html#a9aadbbfe0baa66b6d825636d4211d6bb" title="Construct a PDU using an external buffer. No copy of the buffer is made.">CoapPDU::CoapPDU(uint8_t *pdu, int pduLength)</a>, <a class="el" href="classCoapPDU.html#a3cb874140adc2776f47bbfa20e881e67" title="Memory-managed constructor. Buffer for PDU is dynamically sized and allocated by the object...">CoapPDU::CoapPDU</a>::(uint8_t *buffer, int bufferLength, int pduLength), <a class="el" href="classCoapPDU.html">CoapPDU</a>:<a class="el" href="classCoapPDU.html#a3cb874140adc2776f47bbfa20e881e67" title="Memory-managed constructor. Buffer for PDU is dynamically sized and allocated by the object...">CoapPDU()</a>~ </dd></dl>

</div>
</div>
<a class="anchor" id="a9aadbbfe0baa66b6d825636d4211d6bb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CoapPDU::CoapPDU </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>pdu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>pduLength</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct a PDU using an external buffer. No copy of the buffer is made. </p>
<p>This constructor is normally used where a PDU has been received over the network, and it's length is known. In this case the <a class="el" href="classCoapPDU.html">CoapPDU</a> object is probably going to be used as a temporary container to access member values.</p>
<p>It is assumed that <b>pduLength</b> is the length of the actual CoAP PDU, and consequently the buffer will also be this size, contrast this with <a class="el" href="classCoapPDU.html#a55c638acbe1b4fd7b4a288a126078c86" title="Construct object from external buffer that may be larger than actual PDU.">CoapPDU::CoapPDU(uint8_t *buffer, int bufferLength, int pduLength)</a> which allows the buffer to be larger than the PDU.</p>
<p>A PDU constructed in this manner must be validated with <a class="el" href="classCoapPDU.html#a757ad675b619f32b81c8c435792f4f9c" title="Validates a PDU constructed using an external buffer.">CoapPDU::validate()</a> before the member variables will be accessible.</p>
<dl class="section warning"><dt>Warning</dt><dd>The validation call parses the PDU structure to set some internal parameters. If you do not validate the PDU, then the behaviour of member access functions will be undefined.</dd></dl>
<p>The buffer can be reused by issuing a <a class="el" href="classCoapPDU.html#add695cf1e57cae13cfbfb9b6964a4456" title="Reset CoapPDU container so it can be reused to build a new PDU.">CoapPDU::reset()</a> but the class will not change the size of the buffer. If the newly constructed PDU exceeds the size of the buffer, the function called (for example <a class="el" href="classCoapPDU.html#aab90c3016ce4eeb3b8580e43233e131f" title="Add an option to the PDU.">CoapPDU::addOption</a>) will fail.</p>
<p>Deleting this object will only delete the Object container and will not delete the PDU buffer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pdu</td><td>A pointer to an array of bytes which comprise the CoAP PDU </td></tr>
    <tr><td class="paramname">pduLength</td><td>The length of the CoAP PDU pointed to by <b>pdu</b> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="classCoapPDU.html#a3cb874140adc2776f47bbfa20e881e67" title="Memory-managed constructor. Buffer for PDU is dynamically sized and allocated by the object...">CoapPDU::CoapPDU()</a>, <a class="el" href="classCoapPDU.html#a55c638acbe1b4fd7b4a288a126078c86" title="Construct object from external buffer that may be larger than actual PDU.">CoapPDU::CoapPDU(uint8_t *buffer, int bufferLength, int pduLength)</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a55c638acbe1b4fd7b4a288a126078c86"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CoapPDU::CoapPDU </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>bufferLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>pduLength</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct object from external buffer that may be larger than actual PDU. </p>
<p>This differs from <a class="el" href="classCoapPDU.html#a9aadbbfe0baa66b6d825636d4211d6bb" title="Construct a PDU using an external buffer. No copy of the buffer is made.">CoapPDU::CoapPDU(uint8_t *pdu, int pduLength)</a> in that the buffer may be larger than the actual CoAP PDU contained int the buffer. This is typically used when a large buffer is reused multiple times. Note that <b>pduLength</b> can be 0.</p>
<p>If an actual CoAP PDU is passed in the buffer, <b>pduLength</b> should match its length. <a class="el" href="classCoapPDU.html#a757ad675b619f32b81c8c435792f4f9c" title="Validates a PDU constructed using an external buffer.">CoapPDU::validate()</a> must be called to initiate the object before member functions can be used.</p>
<p>A PDU constructed in this manner must be validated with <a class="el" href="classCoapPDU.html#a757ad675b619f32b81c8c435792f4f9c" title="Validates a PDU constructed using an external buffer.">CoapPDU::validate()</a> before the member variables will be accessible.</p>
<dl class="section warning"><dt>Warning</dt><dd>The validation call parses the PDU structure to set some internal parameters. If you do not validate the PDU, then the behaviour of member access functions will be undefined.</dd></dl>
<p>The buffer can be reused by issuing a <a class="el" href="classCoapPDU.html#add695cf1e57cae13cfbfb9b6964a4456" title="Reset CoapPDU container so it can be reused to build a new PDU.">CoapPDU::reset()</a> but the class will not change the size of the buffer. If the newly constructed PDU exceeds the size of the buffer, the function called (for example <a class="el" href="classCoapPDU.html#aab90c3016ce4eeb3b8580e43233e131f" title="Add an option to the PDU.">CoapPDU::addOption</a>) will fail.</p>
<p>Deleting this object will only delete the Object container and will not delete the PDU buffer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>A buffer which either contains a CoAP PDU or is intended to be used to construct one. </td></tr>
    <tr><td class="paramname">bufferLength</td><td>The length of the buffer </td></tr>
    <tr><td class="paramname">pduLength</td><td>If the buffer contains a CoAP PDU, this specifies the length of the PDU within the buffer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="classCoapPDU.html#a3cb874140adc2776f47bbfa20e881e67" title="Memory-managed constructor. Buffer for PDU is dynamically sized and allocated by the object...">CoapPDU::CoapPDU()</a>, <a class="el" href="classCoapPDU.html#a9aadbbfe0baa66b6d825636d4211d6bb" title="Construct a PDU using an external buffer. No copy of the buffer is made.">CoapPDU::CoapPDU(uint8_t *pdu, int pduLength)</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a00473911b9b2c209a0c25c75ef4a1a77"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CoapPDU::~CoapPDU </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destructor. Does not free buffer if constructor passed an external buffer. </p>
<p>The destructor acts differently, depending on how the object was initially constructed (from buffer or not):</p>
<ol type="1">
<li><a class="el" href="classCoapPDU.html#a3cb874140adc2776f47bbfa20e881e67" title="Memory-managed constructor. Buffer for PDU is dynamically sized and allocated by the object...">CoapPDU::CoapPDU()</a> <pre class="fragment"> Complete object is destroyed.
</pre></li>
</ol>
<ol type="1">
<li><a class="el" href="classCoapPDU.html#a9aadbbfe0baa66b6d825636d4211d6bb" title="Construct a PDU using an external buffer. No copy of the buffer is made.">CoapPDU::CoapPDU(uint8_t *pdu, int pduLength)</a> <pre class="fragment"> Only object container is destroyed. \b pdu is left intact.
</pre></li>
</ol>
<ol type="1">
<li><a class="el" href="classCoapPDU.html#a55c638acbe1b4fd7b4a288a126078c86" title="Construct object from external buffer that may be larger than actual PDU.">CoapPDU::CoapPDU(uint8_t *buffer, int bufferLength, int pduLength)</a> <pre class="fragment"> Only object container is destroyed. \b pdu is left intact.</pre> </li>
</ol>

</div>
</div>
<h2>Member Function Documentation</h2>
<a class="anchor" id="aab90c3016ce4eeb3b8580e43233e131f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int CoapPDU::addOption </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>insertedOptionNumber</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>optionValueLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>optionValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add an option to the PDU. </p>
<p>Unlike other implementations, options can be added in any order, and in-memory manipulation will be performed to ensure the correct ordering of options (they use a delta encoding of option numbers). Re-ordering memory like this incurs a small performance cost, so if you care about this, then you might want to add options in ascending order of option number. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">optionNumber</td><td>The number of the option, see the enum <a class="el" href="classCoapPDU.html#a14532c22e1b6afd2f97300afefc45aee" title="CoAP option numbers.">CoapPDU::Option</a> for shorthand notations. </td></tr>
    <tr><td class="paramname">optionLength</td><td>The length of the option payload in bytes. </td></tr>
    <tr><td class="paramname">optionValue</td><td>A pointer to the byte sequence that is the option payload (bytes will be copied). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, 1 on failure. </dd></dl>

</div>
</div>
<a class="anchor" id="a206a01d5de8f1bb4ca6ae3b7825a7b02"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structCoapPDU_1_1CoapOption.html">CoapPDU::CoapOption</a> * CoapPDU::getOptions </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This returns the options as a sequence of structs. </p>

</div>
</div>
<a class="anchor" id="ab84a11627b55810181d82b673d674468"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int CoapPDU::getURI </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dstlen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>outLen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Concatenates any URI_PATH elements into a single string. </p>
<p>Parses the PDU options and extracts all URI_PATH elements, concatenating them into a single string with slash separators.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dst</td><td>Buffer into which to copy the concatenated path elements. </td></tr>
    <tr><td class="paramname">dstlen</td><td>Length of buffer. </td></tr>
    <tr><td class="paramname">outLen</td><td>Pointer to integer, into which URI length will be placed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, 1 on failure. <b>outLen</b> will contain the length of the concatenated elements. </dd></dl>

</div>
</div>
<a class="anchor" id="a6e4d0602e21b8f55d12dd2a57e0db051"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t CoapPDU::getVersion </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets the CoAP Version. </p>
<dl class="section return"><dt>Returns</dt><dd>The CoAP version between 0 and 3. </dd></dl>

</div>
</div>
<a class="anchor" id="a73fa1f5ddfa6be212d2e5e1182c4afc3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t * CoapPDU::mallocPayload </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>len</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate space for a payload. </p>
<p>For dynamically constructed PDUs, this will allocate space for a payload in the object and return a pointer to it. If the PDU was constructed from a buffer, this doesn't malloc anything, it just changes the _pduLength and returns the payload pointer.</p>
<dl class="section note"><dt>Note</dt><dd>The pointer returned points into the PDU buffer. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">len</td><td>The length of the payload buffer to allocate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Either a pointer to the payload buffer, or NULL if there wasn't enough space / allocation failed. </dd></dl>

</div>
</div>
<a class="anchor" id="ab00a78b493dc0df018f3a3e5ee058d15"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CoapPDU::printOptionHuman </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>option</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A routine for printing an option in human-readable format. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">option</td><td>This is a pointer to where the option begins in the PDU. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="add695cf1e57cae13cfbfb9b6964a4456"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int CoapPDU::reset </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reset <a class="el" href="classCoapPDU.html">CoapPDU</a> container so it can be reused to build a new PDU. </p>
<p>This resets the <a class="el" href="classCoapPDU.html">CoapPDU</a> container, setting the pdu length, option count, etc back to zero. The PDU can then be populated as if it were newly constructed.</p>
<p>Note that the space available will depend on how the <a class="el" href="classCoapPDU.html">CoapPDU</a> was originally constructed:</p>
<ol type="1">
<li><a class="el" href="classCoapPDU.html#a3cb874140adc2776f47bbfa20e881e67" title="Memory-managed constructor. Buffer for PDU is dynamically sized and allocated by the object...">CoapPDU::CoapPDU()</a> <pre class="fragment"> Available space initially be \b _pduLength. But further space will be allocated as needed on demand, 
</pre> limited only by the OS/environment.</li>
</ol>
<ol type="1">
<li><a class="el" href="classCoapPDU.html#a9aadbbfe0baa66b6d825636d4211d6bb" title="Construct a PDU using an external buffer. No copy of the buffer is made.">CoapPDU::CoapPDU(uint8_t *pdu, int pduLength)</a> <pre class="fragment"> Space is limited by the variable \b pduLength. The PDU cannot exceed \b pduLength bytes.
</pre></li>
</ol>
<ol type="1">
<li><a class="el" href="classCoapPDU.html#a55c638acbe1b4fd7b4a288a126078c86" title="Construct object from external buffer that may be larger than actual PDU.">CoapPDU::CoapPDU(uint8_t *buffer, int bufferLength, int pduLength)</a> <pre class="fragment"> Space is limited by the variable \b bufferLength. The PDU cannot exceed \b bufferLength bytes.
</pre></li>
</ol>
<dl class="section return"><dt>Returns</dt><dd>0 on success, 1 on failure. </dd></dl>

</div>
</div>
<a class="anchor" id="afc7d3485afa5f4c84f55a41562305d0f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int CoapPDU::setContentFormat </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classCoapPDU.html#a47254e03045e0ad9617b231a0589b98d">CoapPDU::ContentFormat</a>&#160;</td>
          <td class="paramname"><em>format</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Shorthand for setting the content-format option. </p>
<p>Sets the content-format to the specified value (adds an option). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">format</td><td>The content format, one of:</td></tr>
  </table>
  </dd>
</dl>
<ul>
<li>COAP_CONTENT_FORMAT_TEXT_PLAIN</li>
<li>COAP_CONTENT_FORMAT_APP_LINK</li>
<li>COAP_CONTENT_FORMAT_APP_XML</li>
<li>COAP_CONTENT_FORMAT_APP_OCTET</li>
<li>COAP_CONTENT_FORMAT_APP_EXI</li>
<li>COAP_CONTENT_FORMAT_APP_JSON</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>0 on success, 1 on failure. </dd></dl>

</div>
</div>
<a class="anchor" id="afd64c65662e72058abe6008a1abe08ec"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int CoapPDU::setMessageID </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>messageID</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set messageID to the supplied value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">messageID</td><td>A 16bit message id. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, 1 on failure. </dd></dl>

</div>
</div>
<a class="anchor" id="a68d5b39701189a853eb5403a1a1a77e0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int CoapPDU::setPayload </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>payload</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the payload to the byte sequence specified. Allocates memory in dynamic PDU if necessary. </p>
<p>This will set the payload to <b>payload</b>. It will allocate memory in the case where the PDU was constructed without an external buffer.</p>
<p>This will fail either if the fixed buffer isn't big enough, or if memory could not be allocated in the non-external-buffer case.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">payload</td><td>Pointer to payload byte sequence. </td></tr>
    <tr><td class="paramname">len</td><td>Length of payload byte sequence. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, 1 on failure. </dd></dl>

</div>
</div>
<a class="anchor" id="adafa3fa099f4ba5248a05bb4a120bbed"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int CoapPDU::setToken </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>token</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>tokenLength</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the PDU token to the supplied byte sequence. </p>
<p>This sets the PDU token to <b>token</b> and sets the token length to <b>tokenLength</b>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">token</td><td>A sequence of bytes representing the token. </td></tr>
    <tr><td class="paramname">tokenLength</td><td>The length of the byte sequence. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, 1 on failure. </dd></dl>

</div>
</div>
<a class="anchor" id="a371af095ec9b05194212abe4d3df5e6d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int CoapPDU::setTokenLength </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>tokenLength</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the token length. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tokenLength</td><td>The length of the token in bytes, between 0 and 8. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, 1 on failure. </dd></dl>

</div>
</div>
<a class="anchor" id="a5aed3e2860acdd3beeac6a812fcf4700"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CoapPDU::setType </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classCoapPDU.html#a344de2a536c11a30bc370202605a47c3">CoapPDU::Type</a>&#160;</td>
          <td class="paramname"><em>mt</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the type of this CoAP PDU. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mt</td><td>The type, one of:<ul>
<li>COAP_CONFIRMABLE</li>
<li>COAP_NON_CONFIRMABLE</li>
<li>COAP_ACKNOWLEDGEMENT</li>
<li>COAP_RESET. </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a5a53a8147901753189773d9eabe1d142"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int CoapPDU::setURI </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>uri</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>urilen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Shorthand function for setting a resource URI. </p>
<p>This will parse the supplied <b>uri</b> and construct enough URI_PATH CoAP options to encode it. The options are added to the PDU.</p>
<p>At present queries are not handled. TODO Implement queries.</p>
<dl class="section note"><dt>Note</dt><dd>This uses an internal buffer of 16 bytes to manipulate strings. The internal buffer will be expanded dynamically if necessary (path component longer than 16 bytes). The internal buffer will be freed before the function returns.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">uri</td><td>The uri to parse. </td></tr>
    <tr><td class="paramname">urilen</td><td>The length of the uri to parse.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 on success, 0 on failure. </dd></dl>

</div>
</div>
<a class="anchor" id="ad20036b2ab718aa1fe0303cadfa091d6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int CoapPDU::setVersion </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>version</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the CoAP version. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">version</td><td>CoAP version between 0 and 3. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, 1 on failure. </dd></dl>

</div>
</div>
<a class="anchor" id="a757ad675b619f32b81c8c435792f4f9c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int CoapPDU::validate </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Validates a PDU constructed using an external buffer. </p>
<p>When a <a class="el" href="classCoapPDU.html">CoapPDU</a> is constructed using an external buffer, the programmer must call this function to check that the received PDU is a valid CoAP PDU.</p>
<dl class="section warning"><dt>Warning</dt><dd>The validation call parses the PDU structure to set some internal parameters. If you do not validate the PDU, then the behaviour of member access functions will be undefined.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>1 if the PDU validates correctly, 0 if not. XXX maybe add some error codes </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="cantcoap_8h_source.html">cantcoap.h</a></li>
<li>cantcoap.cpp</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Mon Oct 7 2013 14:40:05 for Can't CoAP by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.1.2
</small></address>
</body>
</html>
